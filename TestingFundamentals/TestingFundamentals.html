<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Prepare yourself</title>

    <link rel="canonical" href="https://getbootstrap.com/docs/5.3/examples/features/">
    <link href="../assets/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="../custom/mycustomstyle.css" rel="stylesheet">
  </head>
  <body>
    <main>
      <div class="container px-4 py-5" id="icon-grid">
        <h2 class="pb-2 border-bottom" style="transform: rotate(0);""><a class="stretched-link" href="../index.html"><a>Test Automation Engineer .NET Questions & Exercises
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-return-left" viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M14.5 1.5a.5.5 0 0 1 .5.5v4.8a2.5 2.5 0 0 1-2.5 2.5H2.707l3.347 3.346a.5.5 0 0 1-.708.708l-4.2-4.2a.5.5 0 0 1 0-.708l4-4a.5.5 0 1 1 .708.708L2.707 8.3H12.5A1.5 1.5 0 0 0 14 6.8V2a.5.5 0 0 1 .5-.5z"></path>
          </svg>
        </h2>
      </div>
      
      <div class="container">
        <div class="row">
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question1">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading1">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse1" aria-expanded="false" aria-controls="flush-collapse1">
                    1. What is Software Testing?
                  </button>
                </h2>
                <div id="flush-collapse1" class="accordion-collapse collapse" aria-labelledby="flush-heading1" data-bs-parent="#question1">
                  <div class="accordion-body">It's a process to:
                  <ul class="list-group list-group-flush" id="question1-list-group">
                    <li class="list-group-item">ensure that the software meets the agreed requirements and works as was planned.</li>
                    <li class="list-group-item">ensure the application doesn't contain serious bugs.</li>
                  </ul>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question2">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading2">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse2" aria-expanded="false" aria-controls="flush-collapse2">
                    2. Software Testing Validation vs. Verification
                  </button>
                </h2>
                <div id="flush-collapse2" class="accordion-collapse collapse" aria-labelledby="flush-heading2" data-bs-parent="#question2">
                  <div class="accordion-body">
                    <ul class="list-group list-group-flush" id="question2-list-group">
                      <li class="list-group-item"><b>Validation:</b> what we need to do at all?</li>
                      <li class="list-group-item"><b>Verification:</b> we've found out what we need to do. Are we doing it the right way?</li>
                    </ul>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question3">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading3">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse3" aria-expanded="false" aria-controls="flush-collapse3">
                    3. What is Exploratory Testing?
                  </button>
                </h2>
                <div id="flush-collapse3" class="accordion-collapse collapse" aria-labelledby="flush-heading3" data-bs-parent="#question3">
                  <div class="accordion-body">
                    <b>Exploratory Testing</b> is a type of software testing where test cases are not created in advance but testers check the system on the fly. They may note down ideas about what to test before test execution.
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question4">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading4">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse4" aria-expanded="false" aria-controls="flush-collapse4">
                    4. How much testing is enough?
                  </button>
                </h2>
                <div id="flush-collapse4" class="accordion-collapse collapse" aria-labelledby="flush-heading4" data-bs-parent="#question4">
                  <div class="accordion-body">
                    <p>We can use risk metrics (risk-based testing) to identify the likely scenarios that can cause the most harm or the sections of the software that is mostly used so that we focus our time and effort to the sections that are most important.</p>
                    <p>
                      <ul class="list-group rbt">
                        <li class="list-group-item"><h5>Risk Based Testing Approach:</h5></li>
                        <li class="list-group-item"><b>1.</b> Analyze the requirements.</li>
                        <li class="list-group-item"><b>2.</b> Documents (Usecases) are reviewed.</li>
                        <li class="list-group-item"><b>3.</b> Requirements sign-off's is one of the risk-reduction technique for avoiding the introduction of late changes into the projects. Any changes to requirements after the document are baselined would involve a change control process and subsequent approvals.</li>
                        <li class="list-group-item"><b>4.</b> Assess the risks by calculating the likelihood and impact each requirement could have on the project taking the defined criteria's like cost, schedule, resources, scope, technical performance safety, reliability, complexity, etc. into consideration.</li>
                        <li class="list-group-item"><b>5.</b> Identify the probability of failure and high-risk areas. This can be done using risk assessment matrix.Assess the risks by calculating the likelihood and impact each requirement could have on the project taking the defined criteriaâ€™s like cost, schedule, resources, scope, technical performance safety, reliability, complexity, etc. into consideration.</li>
                        <li class="list-group-item"><b>6.</b> Plan and define test according to the rating. Prepare test data and test conditions and test bed.</li>
                        <li class="list-group-item"><b>7.</b> Perform dry runs, execute test cases and quality checks on the results.</li>
                      </ul>
                    </p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question5">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading5">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse5" aria-expanded="false" aria-controls="flush-collapse5">
                    5. What is White Box Testing?
                  </button>
                </h2>
                <div id="flush-collapse5" class="accordion-collapse collapse" aria-labelledby="flush-heading5" data-bs-parent="#question5">
                  <div class="accordion-body">
                    <p><b>White box testing</b> deals with the internal logic and structure of the code.</p>
                    <p>In order to implement <b>white box testing</b>, the tester has to deal with the code and hence is needed to possess knowledge of coding and logic i.e. internal working of the code.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question6">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading6">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse6" aria-expanded="false" aria-controls="flush-collapse6">
                    6. What is Unit Testing?
                  </button>
                </h2>
                <div id="flush-collapse6" class="accordion-collapse collapse" aria-labelledby="flush-heading6" data-bs-parent="#question6">
                  <div class="accordion-body">
                    <p>A developer carries out unit testing in order to check if the particular module or unit of code is working fine.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question7">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading7">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse7" aria-expanded="false" aria-controls="flush-collapse7">
                    7. What is Black Box Testing?
                  </button>
                </h2>
                <div id="flush-collapse7" class="accordion-collapse collapse" aria-labelledby="flush-heading7" data-bs-parent="#question7">
                  <div class="accordion-body">
                    <p>In Black Box Testing, the tester tests an application without knowledge of the internal workings of the application being tested.</p>
                    <ul class="list-group" id="blackbox-testing">
                      <li class="list-group-item"><b>1.</b> The test is unbiased because the designer and the tester are independent of each other. From the point of view of the user</li>
                      <li class="list-group-item"><b>2.</b> Test cases can be designed as soon as the specifications are complete.</li>
                      <li class="list-group-item"><b>3.</b> Testing every possible input stream is unrealistic because it would take a inordinate amount of time; therefore, many program paths will go untested.</li>
                    </ul>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question8">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading8">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse8" aria-expanded="false" aria-controls="flush-collapse8">
                    8. The difference between Smoke and Regression testing?
                  </button>
                </h2>
                <div id="flush-collapse8" class="accordion-collapse collapse" aria-labelledby="flush-heading8" data-bs-parent="#question8">
                  <div class="accordion-body">
                    <p><b>Smoke:</b> typically, <b>smoke testing</b> is conducted whenever a new build or version of the software is deployed. It helps ensure that the basic functionalities are working before further testing is carried out.</p>
                    <p><b>Regression:</b> <b>regression testing</b> should ideally be performed after every significant code change, feature addition, or bug fix. It ensures that the software remains stable and that existing functionalities are not affected by recent modifications.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question9">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading9">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse9" aria-expanded="false" aria-controls="flush-collapse9">
                    9. What is Gray Box Testing?
                  </button>
                </h2>
                <div id="flush-collapse9" class="accordion-collapse collapse" aria-labelledby="flush-heading9" data-bs-parent="#question9">
                  <div class="accordion-body">
                    <p>This is another type of testing in which we look into the box which is being tested, It is done only to understand how it has been implemented. After that, we close the box and use the black box testing.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question10">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading10">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse10" aria-expanded="false" aria-controls="flush-collapse10">
                    10. What is a Use Case?
                  </button>
                </h2>
                <div id="flush-collapse10" class="accordion-collapse collapse" aria-labelledby="flush-heading10" data-bs-parent="#question10">
                  <div class="accordion-body">
                    <p>A use case is a list of actions or event steps typically defining the interactions between a role/actor and a system to achieve a goal.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question11">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading11">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse11" aria-expanded="false" aria-controls="flush-collapse11">
                    11. Explain Bug Severity.
                  </button>
                </h2>
                <div id="flush-collapse11" class="accordion-collapse collapse" aria-labelledby="flush-heading11" data-bs-parent="#question11">
                  <div class="accordion-body">
                    <p><b>Bug severity</b> is a measure of the impact that a bug has on the functionality of a software system. It is typically classified into different levels or categories, such as <semi-b>critical</semi-b>, <semi-b>high</semi-b>, <semi-b>medium</semi-b>, or <semi-b>low</semi-b> severity, based on the severity of its consequences and the impact it has on the system's functionality. This classification helps prioritize bug fixes based on the severity of the bug and its potential impact on the system.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question12">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading12">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse12" aria-expanded="false" aria-controls="flush-collapse12">
                    12. What should be the expected output of QA?
                  </button>
                </h2>
                <div id="flush-collapse12" class="accordion-collapse collapse" aria-labelledby="flush-heading12" data-bs-parent="#question12">
                  <div class="accordion-body">
                    <p>Generally, the goal of QA is to ensure that the software meets the quality standards and requirements that have been established for it.</p>
                    <p>For example, if the QA method being used is functional testing, the expected output would be a report that details any issues found during the testing process, such as bugs, usability issues, or missing functionality.</p>
                    <p>Similarly, if the QA method being used is performance testing, the expected output would be a report that details how the software performs under different conditions, such as high user loads or heavy data volumes.</p>
                    <p>In general, the expected output of a QA method should provide insights into the overall quality of the software being tested and help identify any issues or areas of improvement that need to be addressed. It should also provide actionable recommendations for how to address any issues found and improve the overall quality of the software.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question13">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading13">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse13" aria-expanded="false" aria-controls="flush-collapse13">
                    13. What factors can affect the success of a QA testing process?
                  </button>
                </h2>
                <div id="flush-collapse13" class="accordion-collapse collapse" aria-labelledby="flush-heading13" data-bs-parent="#question13">
                  <div class="accordion-body">
                    <p>Several factors can affect the success of a QA (Quality Assurance) testing process. Some of the key factors are:</p>
                    <p><b>1. Test Planning:</b> Proper planning and preparation of testing activities can significantly impact the effectiveness of the QA process. This includes defining test objectives, identifying the scope of testing, selecting the appropriate testing methods and tools, and creating a comprehensive test plan.</p>
                    <p><b>2. Test Environment:</b> The test environment should be properly configured to replicate the production environment and enable effective testing. This includes setting up the necessary hardware and software configurations, data sets, and network conditions to simulate real-world usage scenarios.</p>
                    <p><b>3. Test Data:</b> The quality of test data can significantly impact the accuracy and reliability of test results. It is important to use realistic and representative test data to simulate real-world scenarios and identify potential issues.</p>
                    <p><b>4. Test Execution:</b> The effectiveness of the QA process also depends on how well the tests are executed. This includes conducting tests according to the test plan, identifying and reporting defects accurately, and ensuring that all test results are properly documented.</p>
                    <p><b>5. Communication:</b> Effective communication between team members, stakeholders, and customers is essential for the success of the QA process. This includes regular updates on testing progress, reporting and tracking of defects, and collaboration to resolve issues.</p>
                    <p><b>6. Testing Expertise:</b> The expertise and experience of the testing team can significantly impact the effectiveness of the QA process. Testing professionals should have a solid understanding of testing methodologies, tools, and techniques to ensure that testing is effective and comprehensive.</p>
                    <p><b>7. Time and Budget:</b> Adequate time and budget are critical factors for the success of the QA process. Insufficient time or budget can result in rushed testing, inadequate coverage, and limited resources for fixing defects, which can compromise the quality of the software.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question14">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading14">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse14" aria-expanded="false" aria-controls="flush-collapse14">
                    14. What is the best way to track and report testing results?
                  </button>
                </h2>
                <div id="flush-collapse14" class="accordion-collapse collapse" aria-labelledby="flush-heading14" data-bs-parent="#question14">
                  <div class="accordion-body">
                    <p><b>1. Test Management Tools:</b> Test management tools can provide a centralized platform for organizing, managing, and reporting testing results. These tools typically offer features for creating and managing test cases, executing tests, tracking defects, and generating reports.</p>
                    <p><b>2. Defect Tracking Tools:</b> Defect tracking tools can help testing teams track and report defects, including the steps to reproduce the defect, its severity and priority, and the status of the fix. These tools can also provide dashboards and reports for monitoring defect trends and progress.</p>
                    <p><b>3. Spreadsheets:</b> Spreadsheets can be a simple and effective way to track and report testing results. Testers can use spreadsheets to document test cases, track test results, and report defects. Spreadsheets can also be easily shared and updated by the testing team.</p>
                    <p><b>4. Test Logs:</b> Test logs can be used to record the results of each test, including any issues encountered and the steps taken to resolve them. These logs can be reviewed and analyzed to identify patterns and trends in testing results.</p>
                    <p><b>5. Reports:</b> Reports can be generated to provide a summary of testing results, including the number of tests executed, the pass/fail rate, and any defects found. Reports can be customized to meet the specific needs of stakeholders and can be generated at regular intervals or on an as-needed basis.</p> 
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question15">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading15">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse15" aria-expanded="false" aria-controls="flush-collapse15">
                    15. How do you plan and prioritize your testing activities?
                  </button>
                </h2>
                <div id="flush-collapse15" class="accordion-collapse collapse" aria-labelledby="flush-heading15" data-bs-parent="#question15">
                  <div class="accordion-body">
                    <p><b>1. Identify the testing objectives:</b> Before planning any testing activities, it's essential to define the testing objectives and ensure they align with the project goals. This includes understanding the features to be tested, the testing scope, the quality goals, and the timelines.</p>
                    <p><b>2. Define the testing approach:</b> Once the testing objectives are identified, it's important to define the testing approach. This includes identifying the types of testing to be performed, such as unit testing, integration testing, system testing, and acceptance testing.</p>
                    <p><b>3. Create a testing schedule:</b> After defining the testing approach, a testing schedule should be created to plan when testing activities will be performed. This includes defining the testing phases, estimating the time required for each phase, and defining the test cycles.</p>
                    <p><b>4. Prioritize test cases:</b> Test cases should be prioritized based on their criticality, complexity, and impact on the system. This helps to ensure that the most important tests are performed first and that the testing effort is focused on the areas of the system that are most critical.</p>
                    <p><b>5. Allocate testing resources:</b> Once the test cases are prioritized, testing resources, including personnel and equipment, should be allocated based on the testing schedule and priorities.</p>
                    <p><b>6. Monitor progress:</b> It's important to track and monitor the progress of testing activities regularly. This includes tracking the status of test cases, identifying any issues or defects, and ensuring that testing activities are on track to meet the project goals and timelines.</p>
                    <p><b>7. Adjust priorities and resources:</b> As the testing progresses, priorities and resources may need to be adjusted based on the results of testing. This includes re-prioritizing test cases, reallocating resources, and adjusting the testing schedule to ensure that testing activities remain aligned with project goals and timelines.</p>
                    <p><b>8. Communicate results:</b> Finally, it's important to communicate the results of testing activities to stakeholders, including developers, project managers, and business owners. This includes reporting on the status of test cases, identifying any issues or defects, and providing recommendations for improvements.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question16">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading16">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse16" aria-expanded="false" aria-controls="flush-collapse16">
                    16. What is the importance of Regression Testing?
                  </button>
                </h2>
                <div id="flush-collapse16" class="accordion-collapse collapse" aria-labelledby="flush-heading16" data-bs-parent="#question16">
                  <div class="accordion-body">
                    <p>Regression testing is an important part of the software testing process as it ensures that changes made to the software application do not introduce new bugs or issues that were not present before.</p>
                    <p><b>1. Ensures software stability:</b> Regression testing helps ensure that the software application remains stable and functional after changes are made to the codebase.</p>
                    <p><b>2. Saves time and money:</b> By catching bugs early on in the development process, regression testing helps save time and money that would otherwise be spent on fixing bugs that may have been missed.</p>
                    <p><b>3. Improves software quality:</b> By catching and fixing bugs before they make it into the final product, regression testing helps improve the overall quality of the software application.</p>
                    <p><b>4. Increases customer satisfaction:</b> Customers expect software applications to work as expected, and regression testing helps ensure that the software application meets those expectations.</p>
                    <p><b>5. Mitigates risk:</b> By catching bugs before they make it into the final product, regression testing helps mitigate the risk of software failures and security vulnerabilities. This is especially important for mission-critical applications, such as those used in healthcare, finance, and transportation.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question17">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading17">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse17" aria-expanded="false" aria-controls="flush-collapse17">
                    17. What is the difference between Positive and Negative testing?
                  </button>
                </h2>
                <div id="flush-collapse17" class="accordion-collapse collapse" aria-labelledby="flush-heading17" data-bs-parent="#question17">
                  <div class="accordion-body">
                    <p><b>Positive testing</b> is the process of testing a system or software application by providing valid and expected inputs.</p>
                    <p><b>Negative testing</b>, on the other hand, is the process of testing a system or software application by providing invalid and unexpected inputs to verify that the system can handle such inputs and respond appropriately without crashing or producing incorrect results.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question18">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading18">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse18" aria-expanded="false" aria-controls="flush-collapse18">
                    18. What is Smoke Testing?
                  </button>
                </h2>
                <div id="flush-collapse18" class="accordion-collapse collapse" aria-labelledby="flush-heading18" data-bs-parent="#question18">
                  <div class="accordion-body">
                    <p><b>Smoke testing</b> is a type of software testing that verifies whether the most critical functionalities of an application or system are working correctly after a build or deployment. The purpose of smoke testing is to quickly identify any major issues that could prevent further testing or use of the system. <b>Smoke testing</b> is often performed before more in-depth testing is conducted and can save time and effort by catching major issues early in the development or deployment process.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question19">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading19">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse19" aria-expanded="false" aria-controls="flush-collapse19">
                    19. What is Usability Testing?
                  </button>
                </h2>
                <div id="flush-collapse19" class="accordion-collapse collapse" aria-labelledby="flush-heading19" data-bs-parent="#question19">
                  <div class="accordion-body">
                    <p><b>Usability testing</b> is a type of software testing that evaluates the ease of use, efficiency, and effectiveness of a product, such as a software application, website, or mobile app, from the perspective of the end-user. <b>Usability testing</b> is typically conducted by observing users as they interact with the product and collecting feedback about their experience. The purpose of <b>usability testing</b> is to identify usability issues and opportunities for improvement to enhance the overall user experience and increase user satisfaction. <b>Usability testing</b> can be conducted at various stages of the development process, from early prototypes to the final product release.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question20">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading20">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse20" aria-expanded="false" aria-controls="flush-collapse20">
                    20. What is the importance of Test Coverage?
                  </button>
                </h2>
                <div id="flush-collapse20" class="accordion-collapse collapse" aria-labelledby="flush-heading20" data-bs-parent="#question20">
                  <div class="accordion-body">
                    <p><b>1. Increased confidence:</b> A high degree of test coverage can give developers and testers greater confidence that the system is working as intended and that all critical areas have been tested.</p>
                    <p><b>2. Reduced risk</b>: By testing all parts of the system, test coverage helps reduce the risk of errors and defects that could impact the overall performance and functionality of the system.</p>
                    <p><b>3. Cost-effectiveness:</b> By identifying defects early in the development process, test coverage can help reduce the cost of fixing issues and retesting.</p>
                    <p><b>4. Compliance:</b> In some industries, such as medical or financial, having high test coverage is often a requirement for regulatory compliance.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question21">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading21">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse21" aria-expanded="false" aria-controls="flush-collapse21">
                    21. How do you determine Test Case Coverage?
                  </button>
                </h2>
                <div id="flush-collapse21" class="accordion-collapse collapse" aria-labelledby="flush-heading21" data-bs-parent="#question21">
                  <div class="accordion-body">
                    <p>Test case coverage can be determined by identifying the requirements or specifications of the system under test and then creating test cases that verify that each requirement or specification is fulfilled. This can be done through techniques such as boundary value analysis, equivalence partitioning, and decision table testing. Test coverage can also be measured using tools such as code coverage analysis, which examines which portions of the code have been executed during testing, or requirements traceability matrix, which tracks the relationship between requirements and test cases. The level of test case coverage required will depend on the specific project and its goals.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question22">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading22">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse22" aria-expanded="false" aria-controls="flush-collapse22">
                    22. How do you ensure Test Case Quality?
                  </button>
                </h2>
                <div id="flush-collapse22" class="accordion-collapse collapse" aria-labelledby="flush-heading22" data-bs-parent="#question22">
                  <div class="accordion-body">
                    <p><b>1. Clear and concise test objectives:</b> Test cases should have clear and concise objectives that define what is being tested, how it is being tested, and what the expected results are.</p>
                    <p><b>2. Test case review:</b> Test cases should be reviewed by other members of the team to ensure that they are accurate, complete, and relevant.</p>
                    <p><b>3. Traceability:</b> Test cases should be traceable to the requirements they are intended to test, ensuring that all requirements have been covered.</p>
                    <p><b>4. Test data:</b> Test cases should use appropriate and valid test data to ensure that the test conditions are realistic and cover the intended scenarios.</p>
                    <p><b>5. Maintainability:</b> Test cases should be designed to be easily maintainable, with clear and concise documentation and easy-to-understand steps.</p>
                    <p><b>6. Automated testing:</b> Using automated testing tools can improve the quality and consistency of test cases, ensuring that they are executed accurately and efficiently.</p>
                    <p><b>7. Continuous improvement:</b> Test cases should be continuously reviewed and updated based on feedback, results, and changes to the system, ensuring that they remain effective and relevant over time.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question23">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading23">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse23" aria-expanded="false" aria-controls="flush-collapse23">
                    23. What is the purpose of a Test Checklist?
                  </button>
                </h2>
                <div id="flush-collapse23" class="accordion-collapse collapse" aria-labelledby="flush-heading23" data-bs-parent="#question23">
                  <div class="accordion-body">
                    <p>A test checklist is a document that outlines a list of items to be tested or verified during the testing process. The purpose of a test checklist is to ensure that all important aspects of the software are tested thoroughly and consistently across different testing activities and across different team members. It helps to reduce the risk of missing important test scenarios and to ensure that testing is comprehensive and effective. Test checklists can also serve as a tool for knowledge transfer and to ensure consistency in testing activities.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question24">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading24">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse24" aria-expanded="false" aria-controls="flush-collapse24">
                    24. What is the importance of User Acceptance Testing?
                  </button>
                </h2>
                <div id="flush-collapse24" class="accordion-collapse collapse" aria-labelledby="flush-heading24" data-bs-parent="#question24">
                  <div class="accordion-body">
                    <p><b>User acceptance testing (UAT)</b> is a type of testing where the end-users or customers of a software application test the application to determine if it meets their requirements and can be used in the real-world. The purpose of <b>UAT</b> is to ensure that the application is usable and acceptable to the end-users and meets their needs.</p>
                    <p>The main difference between <b>UAT</b> and other types of testing, such as functional testing and system testing, is that <b>UAT</b> is performed by end-users or customers of the software application, whereas other types of testing are typically performed by software developers or quality assurance professionals. <b>UAT</b> is usually one of the last stages of the software development life cycle and is performed after the application has passed other types of testing.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question25">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading25">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse25" aria-expanded="false" aria-controls="flush-collapse25">
                    25. What is Traceability Matrix?
                  </button>
                </h2>
                <div id="flush-collapse25" class="accordion-collapse collapse" aria-labelledby="flush-heading25" data-bs-parent="#question25">
                  <div class="accordion-body">
                    <p>A traceability matrix is a document that helps in tracing the relationship between two or more documents, requirements, or test artifacts. It is a table that maps requirements to test cases to ensure that each requirement has a corresponding test case and that all requirements are covered by the test cases. The purpose of a traceability matrix is to ensure that all requirements are tested and that there is no gap in the testing process. It helps to track the progress of testing and to identify any missing requirements or test cases.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question26">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading26">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse26" aria-expanded="false" aria-controls="flush-collapse26">
                    26. What is the purpose of Data-Driven Testing?
                  </button>
                </h2>
                <div id="flush-collapse26" class="accordion-collapse collapse" aria-labelledby="flush-heading26" data-bs-parent="#question26">
                  <div class="accordion-body">
                    <p>The purpose of data-driven testing is to use a set of test data to drive the execution of a test script. The test data is typically stored in a database, spreadsheet, or file, and the test script is designed to iterate through the data, performing the same set of actions on each data set. This allows for more efficient testing, as multiple test cases can be executed in a single test script, and variations in test data can be quickly and easily tested. Additionally, data-driven testing can help to identify defects that may not be found through manual testing, and can help to ensure consistent test results across multiple iterations of testing.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question27">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading27">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse27" aria-expanded="false" aria-controls="flush-collapse27">
                    27. What is the Testing Lifecycle?
                  </button>
                </h2>
                <div id="flush-collapse27" class="accordion-collapse collapse" aria-labelledby="flush-heading27" data-bs-parent="#question27">
                  <div class="accordion-body">
                    <p>The testing lifecycle refers to a series of steps or phases that are followed in order to carry out testing activities efficiently and effectively. The testing lifecycle typically includes the following phases:</p>
                    <p><b>1. Test Planning:</b> In this phase, the overall testing strategy and approach are defined, and a detailed test plan is created.</p>
                    <p><b>3. Test Design:</b> In this phase, test cases are designed based on requirements, specifications, and design documents.</p>
                    <p><b>4. Test Execution:</b> In this phase, the actual testing is performed, and the test cases are executed to identify defects and issues.</p>
                    <p><b>5. Test Reporting:</b> In this phase, test results are reported, and defects are logged and tracked.</p>
                    <p><b>6. Test Closure:</b> In this phase, all testing activities are completed, and the testing team prepares a test summary report to provide an overview of the testing activities and results.</p>
                    <p>The testing lifecycle is iterative in nature and may need to be repeated multiple times, especially during the software development lifecycle.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question28">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading28">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse28" aria-expanded="false" aria-controls="flush-collapse28">
                    28. What is the difference between Functional and Non-Functional testing?
                  </button>
                </h2>
                <div id="flush-collapse28" class="accordion-collapse collapse" aria-labelledby="flush-heading28" data-bs-parent="#question28">
                  <div class="accordion-body">
                    <p><b>Functional testing</b> and <b>non-functional testing</b> are two broad categories of software testing. The main difference between them is that <b>functional testing</b> is concerned with testing the functionality or behavior of the software, while <b>non-functional testing</b> is focused on testing the non-functional aspects of the software, such as <b>performance</b>, <b>security</b>, <b>usability</b>, and <b>reliability</b>.</p>
                    <p><b>Functional testing</b> is used to verify that the software meets the specified functional requirements and performs its intended functions correctly. This type of testing checks that the software behaves as expected in response to various inputs and under different conditions. <b>Functional testing</b> is typically performed using test cases that are based on the requirements or specifications of the software.</p>
                    <p><b>Non-functional testing</b>, on the other hand, is used to verify that the software meets the non-functional requirements, such as <b>performance</b>, <b>security</b>, <b>usability</b>, and <b>reliability</b>. This type of testing checks the quality attributes of the software, which are not related to the functionality. <b>Non-functional testing</b> is typically performed using various techniques, such as <b>load testing</b>, <b>stress testing</b>, <b>security testing</b>, and <b>usability testing</b>, among others.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question29">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading29">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse29" aria-expanded="false" aria-controls="flush-collapse29">
                    29. What is Stress Testing?
                  </button>
                </h2>
                <div id="flush-collapse29" class="accordion-collapse collapse" aria-labelledby="flush-heading29" data-bs-parent="#question29">
                  <div class="accordion-body">
                    <p><b>Stress testing</b> is a type of software testing that involves evaluating a system's ability to handle a heavy load, beyond its normal operating capacity. It is used to identify the maximum capacity of a system, and to determine its breaking point. The aim of <b>stress testing</b> is to discover any potential bottlenecks or performance issues that may occur under extreme conditions, such as heavy user traffic or high data volumes. <b>Stress testing</b> can also be used to validate the system's recovery capabilities after a failure or crash.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question30">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading30">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse30" aria-expanded="false" aria-controls="flush-collapse30">
                    30. What is Security Testing?
                  </button>
                </h2>
                <div id="flush-collapse30" class="accordion-collapse collapse" aria-labelledby="flush-heading30" data-bs-parent="#question30">
                  <div class="accordion-body">
                    <p><b>Security testing</b> is a type of software testing that checks if the software or application is secure against potential threats, vulnerabilities, and risks. The goal of <b>security testing</b> is to identify any security weaknesses or vulnerabilities in the software and to ensure that it can withstand potential attacks. <b>Security testing</b> involves various techniques such as vulnerability <b>scanning</b>, <b>penetration testing</b>, <b>risk assessment</b>, and <b>ethical hacking</b>. The testing is performed to ensure the confidentiality, integrity, and availability of the software or application and to meet security compliance standards and regulations.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question31">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading31">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse31" aria-expanded="false" aria-controls="flush-collapse31">
                    31. What is End-to-End Testing?
                  </button>
                </h2>
                <div id="flush-collapse31" class="accordion-collapse collapse" aria-labelledby="flush-heading31" data-bs-parent="#question31">
                  <div class="accordion-body">
                    <p><b>End-to-end testing</b> is a type of software testing that is performed to ensure that the entire software system works as expected from start to finish. It involves testing the system under test in an environment that simulates <b>real-world usage scenarios</b>, such as user interactions, data flow, and system integrations, to ensure that all components of the software system are working together as expected. The goal of <b>end-to-end testing</b> is to identify any issues or defects that may arise when different components of the system interact with each other, as well as to verify that the software system meets the requirements and expectations of its end-users.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question32">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading32">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse32" aria-expanded="false" aria-controls="flush-collapse32">
                    32. What is the difference between Severity and Priority?
                  </button>
                </h2>
                <div id="flush-collapse32" class="accordion-collapse collapse" aria-labelledby="flush-heading32" data-bs-parent="#question32">
                  <div class="accordion-body">
                    <p><b>Severity</b> and <b>priority</b> are two different concepts in software testing:</p>
                    <p><b>Severity</b> refers to the degree of impact a defect or issue has on the system, product, or application being tested. <b>Severity</b> is usually measured on a scale from 1 to 5, with 1 being the most severe and 5 being the least severe. A severe defect could cause system failure or data loss, while a less severe defect might just cause a cosmetic issue or inconvenience for the user.</p>
                    <p><b>Priority</b> refers to the order in which defects or issues should be addressed based on their impact on the project and the stakeholders involved. <b>Priority</b> is usually measured on a scale from 1 to 5, with 1 being the <semi-b>highest priority</semi-b> and 5 being the <semi-b>lowest priority</semi-b>. A high priority defect might need to be fixed immediately to avoid a major impact on the project, while a low priority defect could be addressed later when resources and time permit.</p>
                    <p>In general, severity indicates the impact of a defect on the product, while priority indicates the importance of fixing the defect relative to other tasks and priorities in the project.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question33">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading33">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse33" aria-expanded="false" aria-controls="flush-collapse33">
                    33. What is Ad-Hoc Testing?
                  </button>
                </h2>
                <div id="flush-collapse33" class="accordion-collapse collapse" aria-labelledby="flush-heading33" data-bs-parent="#question33">
                  <div class="accordion-body">
                    <p><b>Ad-hoc testing</b> is a type of software testing that is performed without any formal or pre-defined test cases or plans. It is an informal and unstructured approach where testers randomly test the software application based on their experience, intuition, and knowledge of the application. <b>Ad-hoc testing</b> is typically performed when there is limited time for testing or when a tester wants to explore and identify defects that might not be found through formal testing techniques.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question34">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading34">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse34" aria-expanded="false" aria-controls="flush-collapse34">
                    34. What is Integration Testing?
                  </button>
                </h2>
                <div id="flush-collapse34" class="accordion-collapse collapse" aria-labelledby="flush-heading34" data-bs-parent="#question34">
                  <div class="accordion-body">
                    <p><b>Integration testing</b> is a software testing technique that involves testing the interface between two or more software components or modules after they have been integrated. The purpose of <b>integration testing</b> is to verify that the individual components, when combined, work correctly and meet the requirements and expectations of the system. <b>Integration testing</b> can help identify errors and defects that may arise from the interaction between the components and ensure the overall functionality and performance of the system. It is typically performed after unit testing and before system testing.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question35">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading35">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse35" aria-expanded="false" aria-controls="flush-collapse35">
                    35. What is the difference between Static and Dynamic testing?
                  </button>
                </h2>
                <div id="flush-collapse35" class="accordion-collapse collapse" aria-labelledby="flush-heading35" data-bs-parent="#question35">
                  <div class="accordion-body">
                    <p><b>Static testing</b> and dynamic testing are two different approaches to software testing.</p>
                    <p><b>Static testing</b> is a testing technique in which the software is examined without being executed. This type of testing involves reviewing code, documentation, and other artifacts to identify defects or issues before the software is actually run. Static testing can include techniques such as peer reviews, walkthroughs, and inspections.</p>
                    <p><b>Dynamic testing</b>, on the other hand, involves the execution of the software in order to find defects or issues. This type of testing is performed by executing test cases or test scripts and observing the behavior of the software. <b>Dynamic testing</b> can include techniques such as functional testing, regression testing, and performance testing.</p>
                    <p>In summary, the main difference between static and dynamic testing is that static testing is performed without actually executing the software, while dynamic testing involves executing the software to observe its behavior.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question36">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading36">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse36" aria-expanded="false" aria-controls="flush-collapse36">
                    36. What is Test-Driven Development (TDD)?
                  </button>
                </h2>
                <div id="flush-collapse36" class="accordion-collapse collapse" aria-labelledby="flush-heading36" data-bs-parent="#question36">
                  <div class="accordion-body">
                    <p><b>Test-driven development (TDD)</b> is a software development approach where test cases are created before the actual implementation code. In <b>TDD</b>, a developer first writes a failing test case, and then writes just enough code to make the test pass. This process is repeated for every feature or requirement, with new test cases being added along the way to ensure that previously implemented functionality remains intact. The goal of <b>TDD</b> is to create high-quality, reliable code that is thoroughly tested and easily maintainable.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question37">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading37">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse37" aria-expanded="false" aria-controls="flush-collapse37">
                    37. What is Behavior-Driven Development (BDD)?
                  </button>
                </h2>
                <div id="flush-collapse37" class="accordion-collapse collapse" aria-labelledby="flush-heading37" data-bs-parent="#question37">
                  <div class="accordion-body">
                    <p><b>Behavior-driven development (BDD)</b> is a software development methodology that focuses on defining the expected behavior of a system in natural language, which can be understood by both technical and non-technical stakeholders. <b>BDD</b> involves collaboration between developers, QA testers, and business stakeholders to create a shared understanding of the requirements and desired outcomes of a system. <b>BDD</b> typically involves the use of a domain-specific language (DSL) that allows stakeholders to describe the desired behavior of the system in a structured format. The DSL is then used to generate automated tests that verify the system's behavior. <b>BDD</b> is often used in Agile development methodologies and is intended to promote collaboration and a shared understanding of the system's behavior among all stakeholders.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question38">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading38">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse38" aria-expanded="false" aria-controls="flush-collapse38">
                    38. What is the difference between Sanity Testing and Retesting?
                  </button>
                </h2>
                <div id="flush-collapse38" class="accordion-collapse collapse" aria-labelledby="flush-heading38" data-bs-parent="#question38">
                  <div class="accordion-body">
                    <p><b>Sanity testing</b> and retesting are two different types of testing that serve different purposes.</p>
                    <p><b>Sanity testing</b> is performed after a new build is received to ensure that the most critical functionalities of the system are working as expected. It is a quick and focused test that checks whether the build is stable enough for further testing. <b>Sanity testing</b> is usually performed manually and does not cover all functionalities of the system.</p>
                    <p>Retesting, on the other hand, is performed to verify that a previously failed test case is working correctly after the defect that caused the failure has been fixed. Retesting is done to ensure that the defect has been resolved and the affected functionality is now working as expected. It is usually performed after the fix has been made and the system is rebuilt. Retesting can be performed manually or using automated test scripts.</p>
                    <p>In summary, sanity testing is done to check the stability of the new build, while retesting is done to verify that a previously failed test case is working correctly after the defect has been fixed.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  <div class="col-md-10">
            <div class="accordion accordion-flush" id="question39">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading39">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse39" aria-expanded="false" aria-controls="flush-collapse39">
                    39. What is the difference between Load Testing and Stress Testing?
                  </button>
                </h2>
                <div id="flush-collapse39" class="accordion-collapse collapse" aria-labelledby="flush-heading39" data-bs-parent="#question39">
                  <div class="accordion-body">
                    <p><b>Load testing</b> and stress testing are both performance testing techniques used to evaluate the behavior of a system under specific workloads. However, they differ in the way they apply load to the system and the purpose of testing.</p>
                    <p><b>Load testing</b> involves testing a system under a specific load, usually the expected or maximum user load, to determine its behavior, performance, and responsiveness. It measures the system's ability to handle the expected load and ensures that it is functioning as expected without crashing or slowing down.</p>
                    <p><b>Stress testing</b>, on the other hand, is a technique used to test a system's ability to handle extreme workloads, beyond its design limits, and determine its breaking point. <b>Stress testing</b> is performed to identify the system's failure points and measure how it behaves under extreme conditions.</p>
                    <p>In summary, load testing checks the behavior of a system under expected conditions, while stress testing evaluates the system's performance under extreme conditions.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question40">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading40">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse40" aria-expanded="false" aria-controls="flush-collapse40">
                    40. What is the difference between Usability Testing and User Acceptance Testing?
                  </button>
                </h2>
                <div id="flush-collapse40" class="accordion-collapse collapse" aria-labelledby="flush-heading40" data-bs-parent="#question40">
                  <div class="accordion-body">
                    <p><b>Usability testing</b> and <b>user acceptance testing</b> are two different types of testing, with different objectives and methods.</p>
                    <p><b>Usability testing</b> is performed to evaluate the ease of use and overall user experience of a product, usually a software application or a website. This type of testing involves observing and collecting feedback from users as they perform specific tasks on the product. The aim is to identify any issues with the product's usability, such as confusing navigation or difficult-to-use features, and to make recommendations for improvement.</p>
                    <p>On the other hand, <b>user acceptance testing (UAT)</b> is performed to determine whether a product meets the business requirements and is fit for use from an end-user perspective. UAT is typically carried out by the end-users themselves, who perform a series of predefined tasks to ensure that the product meets their needs and expectations. The focus is on validating the functionality and verifying that the product meets the business goals.</p>
                    <p>In summary, while usability testing is focused on evaluating the user experience of a product, UAT is focused on verifying that the product meets the business requirements and is fit for use from an end-user perspective.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question41">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading41">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse41" aria-expanded="false" aria-controls="flush-collapse41">
                    41. How do you prioritize test cases for a complext enterprise app?
                  </button>
                </h2>
                <div id="flush-collapse41" class="accordion-collapse collapse" aria-labelledby="flush-heading41" data-bs-parent="#question41">
                  <div class="accordion-body">
                    <p><b>Business Impact:</b> by identifying the critical functionalities that directly impact the core business goals and user experience. Test cases covering these high-impact areas take precedence, as any defects here could significantly affect customer satisfaction and revenue.</p>
                    <p><b>Risk Assessment:</b> high-risk features with a high likelihood of failure are tested more rigorously. This involves analyzing historical data, user feedback, and the complexity of the functionality.</p>
                    <p><b>User Scenarios:</b> understanding user scenarios helps identify the most common workflows and interactions. Test cases that cover these scenarios are prioritized as they reflect real-world usage patterns and ensure a smooth user experience.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>  
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question42">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading42">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse42" aria-expanded="false" aria-controls="flush-collapse42">
                    42. What are test design techniques?
                  </button>
                </h2>
                <div id="flush-collapse42" class="accordion-collapse collapse" aria-labelledby="flush-heading42" data-bs-parent="#question42">
                  <div class="accordion-body">
                    <p><b>1) Pairwise testing</b> is a test design technique used to achieve a high level of coverage with fewer test cases. It aims to test combinations of input parameters or variables in a way that each possible pair of values is covered at least once. This helps in detecting defects that might occur due to interactions between different input parameters.</p>
                    <p>Let's consider a scenario where a software application requires testing for various input parameters, such as:</br>
                    </br>Operating System: Windows, macOS, Linux
                    </br>Browser: Chrome, Firefox, Safari
                    </br>Screen Resolution: 1024x768, 1280x1024, 1920x1080
                    </br>Internet Connection: Dial-up, DSL, Fiber</p>
                    <p>Without using pairwise testing, one might have to create a large number of test cases to cover all possible combinations of these parameters. For instance, testing every possible combination would result in 
                      3 * 3 * 3 * 3 = 81 test cases.</p>
                    <p>However, with pairwise testing, the tool or tester would focus on ensuring that each possible pair of values for these parameters is covered at least once.</p>
                    <p>
                    Windows, Chrome, 1024x768, Dial-up
                    </br>Windows, Firefox, 1280x1024, DSL
                    </br>macOS, Safari, 1920x1080, Fiber
                    </br>Linux, Chrome, 1024x768, DSL
                    </br>Windows, Safari, 1280x1024, Dial-up
                    </br>macOS, Chrome, 1920x1080, Dial-up
                    </br>Linux, Firefox, 1024x768, Fiber
                    </br>Windows, Firefox, 1920x1080, DSL
                    </br>macOS, Safari, 1024x768, DSL
                    </br>Linux, Chrome, 1280x1024, Dial-up
                    </p>
                    <p>With only 10 test cases, pairwise testing covers all possible pairs of values for the input parameters. This is significantly fewer than the 81 test cases required for exhaustive testing.</p>
                    <p><b>2) Error guessing</b> is a test design technique where testers use their experience, intuition, and knowledge of the system to predict and identify potential errors or defects. This technique relies on the tester's ability to think like a user and anticipate where problems might occur in the software.</p>
                    <p>Let's say you're testing a web application that allows users to create accounts and upload profile pictures. Based on your experience and understanding of similar systems, you might anticipate potential errors or weak spots such as:</p>
                    <p>1. Uploading an unusually large image file might crash the system due to memory constraints.
                    </br>2. Entering special characters in the username field might cause unexpected behavior or errors.
                    </br>3. Attempting to access the application simultaneously from multiple devices might lead to synchronization issues.
                    </br>4. Entering invalid email formats during registration might not trigger proper error messages.</p>
                    <p>While error guessing is subjective and relies heavily on the tester's expertise, it can be an effective complement to structured testing techniques by uncovering issues that might otherwise go unnoticed.</p>
                    <p><b>3) State transition</b> is a black-box testing technique used to test systems where the behavior of the system changes based on its state. This technique is particularly useful for testing systems with finite states, such as user interfaces, embedded systems, and software with specific workflow states.</p>
                    <p>
                      1. Logged Out: Initial state when the user is not logged in. 
                      </br>2. Logged In: State after successful user authentication.
                      </br>3. Error: State when there's an authentication error.
                    </p>
                    <p>
                      Test Scenario 1: Transition from Logged Out to Logged In (Enter valid credentials and submit the login form.)
                      </br>Test Scenario 2: Transition from Logged Out to Error (Enter invalid credentials and submit the login form.)
                      </br>Test Scenario 3: Transition from Error to Logged In (Provide valid credentials after seeing the error message and submit the login form again.)
                      </br>Test Scenario 4: Transition from Logged In to Logged Out (Trigger the logout action, either by clicking a logout button or navigating to the logout page.)
                      </br>Test Scenario 5: Handling of Session Timeouts (Wait until the session expires due to inactivity.
                      Verify that the system transitions the user from the Logged In state to the Logged Out state after the session timeout.)
                      </br>Test Scenario 6: Concurrent Session Handling (Simulate a scenario where the same user logs in from multiple devices or browsers.
                      Ensure that actions performed in one session do not affect the state of another session.
                      Verify that the system handles concurrent sessions gracefully without causing unexpected state transitions.)
                    </p>
                    <p><b>4) Decision table</b> is a technique used to test the combinations of inputs and their corresponding outputs based on defined rules.</p>
                    <p>
                      We have a web UI form for user registration. The form has the following fields:</br>
                      1. Username (must be between 3 and 20 characters.)
                    </br>2. Email (must be a valid email format.)
                    </br>3. Password (must be at least 8 characters long.)
                    </br>4. Confirm Password (Password must match the Password field.)</br>
                    Based on these rules, we can create a decision table to cover different combinations of inputs and expected outputs.</br>
                    <table class="table table-bordered">
                      <thead>
                        <tr>
                          <th scope="col">Test Case</th>
                          <th scope="col">Username</th>
                          <th scope="col">Email</th>
                          <th scope="col">Password</th>
                          <th scope="col">Confirm Password</th>
                          <th scope="col">Expected Output</th>
                        </tr>
                      </thead>
                      <tbody>
                        <tr>
                          <th scope="row">TC1</th>
                          <td>Valid</td>
                          <td>Valid</td>
                          <td>Valid</td>
                          <td>Valid</td>
                          <td>Registration Success</td>
                        </tr>
                        <tr>
                          <th scope="row">TC2</th>
                          <td>Invalid</td>
                          <td>Valid</td>
                          <td>Valid</td>
                          <td>Valid</td>
                          <td>Registration Failure (Username too short)</td>
                        </tr>
                        <tr>
                          <th scope="row">TC3</th>
                          <td>Valid</td>
                          <td>Invalid</td>
                          <td>Valid</td>
                          <td>Valid</td>
                          <td>Registration Failure (Invalid Email format)</td>
                        </tr>
                        <tr>
                          <th scope="row">TC4</th>
                          <td>Valid</td>
                          <td>Valid</td>
                          <td>Invalid</td>
                          <td>Valid</td>
                          <td>Registration Failure (Password too short)</td>
                        </tr>
                        <tr>
                          <th scope="row">TC5</th>
                          <td>Valid</td>
                          <td>Valid</td>
                          <td>Valid</td>
                          <td>Invalid</td>
                          <td>Registration Failure (Password and Confirm Password mismatch)</td>
                        </tr>
                      </tbody>
                    </table>
                    </p>
                    <p><b>5) Boundary value analysis</b> is applied to explore errors at the boundary of the input domain. Ex. Input is valid between 50 to 100. Boundary values are 49, 50, 51 and 99, 100, 101.</p>
                    <p><b>6) Equivalence partitioning</b> is a testing technique that involves dividing the input domain of a system into groups or partitions that are expected to behave similarly. The primary goal is to reduce redundant testing by selecting representative test cases from each partition. This technique is based on the assumption that if one test case within a partition exposes a defect, the other cases in the same partition are likely to do the same. Ex. input is valid from 5 to 10. There are 3 groups: to 5, from 5 to 10, from 10. So you validate 2 (invalid), 7 (valid), 12 (invalid). </p></div>
                  </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question43">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading43">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse43" aria-expanded="false" aria-controls="flush-collapse43">
                    43. What are levels of testing (unit, integration, system, acceptance) and their objectives?
                  </button>
                </h2>
                <div id="flush-collapse43" class="accordion-collapse collapse" aria-labelledby="flush-heading43" data-bs-parent="#question43">
                  <div class="accordion-body">
                    <p><b>Unit Testing:</b> Objective: To test individual components or units of code in isolation to ensure they function as intended. Approach: Developers typically perform unit testing. It aims to validate the smallest functional pieces of code, such as functions or methods.</p>
                    <p><b>Integration Testing:</b> Objective: To test the interactions between different units or components when integrated together. Approach: Integration testing focuses on validating data flow, communication, and interactions between units. It helps identify issues that may arise due to integration complexities.</p>
                    <p><b>System Testing:</b> Objective: To test the entire system as a whole to ensure all components and interactions work together harmoniously. Approach: System testing verifies the system's compliance with requirements. It involves end-to-end testing of various scenarios, including both functional and non-functional aspects.</p>
                    <p><b>Acceptance Testing:</b> Objective: To determine if the system meets the specified requirements and is ready for release to the end-users. Approach: Acceptance testing is often performed by stakeholders, including users or client representatives. It validates that the system fulfills business requirements and is ready for deployment.</p>
                    <p>To ensure effective coverage across these testing levels:</p>
                    <p><b>Define Clear Test Objectives:</b> Clearly define the goals and objectives for each testing level. This helps align testing efforts with the desired outcomes.</p>
                    <p><b>Requirements Traceability:</b> Ensure that test cases are traced back to the requirements. This ensures that each requirement is adequately tested and verified.</p>
                    <p><b>Test Planning:</b> Create a comprehensive test plan that outlines the testing scope, strategy, resources, and schedules for each testing level.</p>
                    <p><b>Test Case Design:</b> Design test cases that cover various scenarios, including positive, negative, and edge cases, to ensure thorough testing.</p>     
                    <p><b>Test Data:</b> Prepare a diverse set of test data that represents different scenarios and real-world usage patterns.</p>
                    <p><b>Test Automation:</b> Use test automation tools to streamline repetitive tests, especially at the unit and integration levels. Automation increases coverage and efficiency.</p>
                    <p><b>Continuous Integration and Continuous Delivery (CI/CD):</b> Implement CI/CD pipelines to ensure that code changes are frequently integrated, tested, and deployed across different levels.</p>
                    <p><b>Collaboration:</b> Foster collaboration between development, testing, and business teams. This helps in better understanding requirements and identifying potential gaps.</p>
                    <p><b>Risk-Based Testing:</b> Prioritize testing efforts based on risk assessment. Focus on critical areas that could have a significant impact on the system's functionality.</p>
                    <p><b>Defect Management:</b> Maintain a robust defect tracking process to capture, prioritize, and resolve issues identified during testing.</p>
                    <p><b>Feedback Loop:</b> Establish a feedback loop with stakeholders to ensure that testing aligns with their expectations and requirements.</p>
                    <p><b>Regression Testing:</b> Perform regular regression testing to ensure that new changes don't introduce regressions or conflicts with existing functionality.</p>
                  </div>
                </div>
              </div> 
            </div>
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question44">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading44">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse44" aria-expanded="false" aria-controls="flush-collapse44">
                    44. What is a bug and what parts it comprises?
                  </button>
                </h2>
                <div id="flush-collapse44" class="accordion-collapse collapse" aria-labelledby="flush-heading44" data-bs-parent="#question44">
                  <div class="accordion-body">
                    <p>A bug is a flaw or defect in software that causes it to behave unexpectedly or incorrectly.</p>
                    <p><b>Symptom:</b> This is the observable behavior or manifestation of the bug. It's what users or testers notice as an issue.</p>
                    <p><b>Cause:</b> The cause of the bug is the underlying reason why the software behaves incorrectly. It could be due to programming errors, logical mistakes, incorrect assumptions, or unexpected interactions between different parts of the software.</p>
                    <p><b>Impact:</b> The impact of a bug refers to the consequences it has on the system or users. This could range from minor inconveniences to critical failures, depending on the nature of the bug and the context in which the software is used.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question45">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading45">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse45" aria-expanded="false" aria-controls="flush-collapse45">
                    45. Explain the Testing Pyramid.
                  </button>
                </h2>
                <div id="flush-collapse45" class="accordion-collapse collapse" aria-labelledby="flush-heading45" data-bs-parent="#question45">
                  <div class="accordion-body">
                    <p>
                      <div class="container">
                        <img src="TestingPyramid.png" alt="Testing pyramid" class="img-fluid">
                      </div>
                    </p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question46">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading46">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse46" aria-expanded="false" aria-controls="flush-collapse46">
                    46. Explain F.I.R.S.T. principles.
                  </button>
                </h2>
                <div id="flush-collapse46" class="accordion-collapse collapse" aria-labelledby="flush-heading46" data-bs-parent="#question46">
                  <div class="accordion-body">
                    <p><b>Fast:</b> Tests should run quickly to provide immediate feedback, encouraging frequent execution and rapid iteration during development.</p>
                    <p><b>Isolated/Independent:</b> Each test should be self-contained and not dependent on the state or execution of other tests, ensuring that failures are localized and do not impact the entire test suite.</p>
                    <p><b>Repeatable:</b> Tests should produce consistent results regardless of external factors such as environment setup or data dependencies, enabling reliable and reproducible testing.</p>
                    <p><b>Self-Validating:</b> Tests should have a clear pass or fail outcome, with built-in assertions or expectations that automatically verify expected behavior, providing unambiguous feedback on the system's correctness.</p>
                    <p><b>Timely:</b> Tests should be written promptly, ideally alongside the implementation code, to prevent the accumulation of technical debt and ensure the codebase remains testable and maintainable, facilitating early defect detection and continuous integration practices.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question47">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading47">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse47" aria-expanded="false" aria-controls="flush-collapse47">
                    47. Explain 3 A's principle.
                  </button>
                </h2>
                <div id="flush-collapse47" class="accordion-collapse collapse" aria-labelledby="flush-heading47" data-bs-parent="#question47">
                  <div class="accordion-body">
                    <p><b>Arrange:</b> Setting up the necessary preconditions and state required for the test.</p>
                    <p><b>Act:</b> Executing the specific actions or operations that you want to test.</p>
                    <p><b>Assert:</b> Verifying that the outcome of the actions matches the expected behavior.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question48">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading48">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse48" aria-expanded="false" aria-controls="flush-collapse48">
                    48. Explain the concept of Mutation Testing.
                  </button>
                </h2>
                <div id="flush-collapse48" class="accordion-collapse collapse" aria-labelledby="flush-heading48" data-bs-parent="#question48">
                  <div class="accordion-body">
                    <p>It is a software testing technique that involves introducing small changes, known as mutations, into the source code of a program. These mutations simulate potential faults or defects that might occur during software development. After introducing mutations, the test suite is executed to determine if it can detect these mutations.</p>
                    <p>The goal of mutation testing is to evaluate the effectiveness of the test suite in identifying defects in the code. If the test suite can detect the mutations, it indicates that the tests are robust and can identify similar faults in the actual codebase. On the other hand, if the mutations go undetected, it suggests that the test suite may have gaps and needs improvement.</p>
                    <p>It helps improve the quality of software by providing feedback on the effectiveness of the test suite. It helps identify weaknesses in the test coverage and guides developers in writing more comprehensive tests. Additionally, mutation testing helps prioritize test cases based on their ability to detect faults, leading to more efficient testing efforts.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question49">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading49">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse49" aria-expanded="false" aria-controls="flush-collapse49">
                    49. Explain the concept of "Heisenbug".
                  </button>
                </h2>
                <div id="flush-collapse49" class="accordion-collapse collapse" aria-labelledby="flush-heading49" data-bs-parent="#question49">
                  <div class="accordion-body">
                    <p>A Heisenbug is a software bug or defect that seems to disappear or change its behavior when attempts are made to isolate and fix it. These bugs often occur due to the timing or environmental conditions under which they manifest. Strategies for debugging Heisenbugs include using logging and tracing mechanisms to capture runtime behavior, creating reproducible test cases to isolate the bug, and using debugging tools to inspect variables and program state at various points in the execution flow.</p>
                    <p>A multi-threaded application where multiple threads are concurrently accessing and modifying shared resources. Occasionally, developers might encounter a situation where the application behaves unexpectedly or crashes sporadically, but the issue cannot be consistently reproduced.</p>
                    <p>Due to the non-deterministic nature of thread scheduling, the timing of thread execution may vary from one run to another. In some instances, a particular thread might acquire the lock and proceed without any issues. However, under different timing conditions, another thread might acquire the lock first, leading to a race condition or deadlock situation that causes the application to crash.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>
          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question50">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading50">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse50" aria-expanded="false" aria-controls="flush-collapse50">
                    50. What's the Definition of Done?
                  </button>
                </h2>
                <div id="flush-collapse50" class="accordion-collapse collapse" aria-labelledby="flush-heading50" data-bs-parent="#question50">
                  <div class="accordion-body">
                    <p>The "Definition of Done" (DoD) is a set of criteria or requirements that must be met for a user story, feature, or task to be considered complete and ready for delivery. It ensures that work meets the team's quality standards and is potentially shippable. The Definition of Done typically includes criteria related to coding, testing, documentation, integration, and acceptance. It helps maintain consistency and transparency in the development process and ensures that stakeholders have a clear understanding of when work is truly finished.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>

          <div class="col-md-10">
            <div class="accordion accordion-flush" id="question51">
              <div class="accordion-item">
                <h2 class="accordion-header" id="flush-heading51">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#flush-collapse51" aria-expanded="false" aria-controls="flush-collapse51">
                    51. Stub vs. Mock?
                  </button>
                </h2>
                <div id="flush-collapse51" class="accordion-collapse collapse" aria-labelledby="flush-heading51" data-bs-parent="#question51">
                  <div class="accordion-body">
                    <p>.</p>
                  </div>
                </div>
              </div>
            </div> 
          </div>
          <div class="col-md-2">
          </div>

        </div>
      </div>
      <div class="bottom-end">
      </div>
    </main>
    <script src="../assets/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>